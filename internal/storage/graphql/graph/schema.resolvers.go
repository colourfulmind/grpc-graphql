package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"ozon/internal/storage"
	"ozon/internal/storage/graphql/graph/model"
)

// SaveUser is the resolver for the SaveUser field.
func (r *mutationResolver) SaveUser(ctx context.Context, input model.UserInput) (int, error) {
	const op = "internal/storage/graphql.SaveUser"

	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	done := make(chan struct{}, 1)
	errExists := make(chan struct{}, 1)
	errQuery := make(chan struct{}, 1)

	var userID int64
	go func() {
		err := r.DB.QueryRow("SELECT id FROM users WHERE email = $1", input.Email).Scan(&userID)
		if errors.Is(err, sql.ErrNoRows) {
			err = r.DB.QueryRow("INSERT INTO users (email, password) VALUES ($1, $2) RETURNING id", input.Email, input.Password).Scan(&userID)
			if err != nil {
				errQuery <- struct{}{}
			} else {
				done <- struct{}{}
			}
		} else {
			if !errors.Is(err, sql.ErrNoRows) {
				errExists <- struct{}{}
			} else {
				errQuery <- struct{}{}
			}
		}
		close(errQuery)
		close(errExists)
		close(done)
	}()

	select {
	case <-errExists:
		return 0, fmt.Errorf("%s: %w", op, storage.ErrUserExists)
	case <-errQuery:
		return 0, fmt.Errorf("%s: %w", op, storage.ErrQuery)
	case <-ctx.Done():
		return 0, fmt.Errorf("%s: %w", op, storage.ErrConnectionTime)
	case <-done:
		return int(userID), nil
	}
}

// ProvideUserByEmail is the resolver for the ProvideUserByEmail field.
func (r *mutationResolver) ProvideUserByEmail(ctx context.Context, input model.UserByEmailInput) (*model.User, error) {
	panic(fmt.Errorf("not implemented: ProvideUserByEmail - ProvideUserByEmail"))
}

// ProvideUserByID is the resolver for the ProvideUserByID field.
func (r *mutationResolver) ProvideUserByID(ctx context.Context, input model.UserByIDInput) (*model.User, error) {
	panic(fmt.Errorf("not implemented: ProvideUserByID - ProvideUserByID"))
}

// SavePost is the resolver for the SavePost field.
func (r *mutationResolver) SavePost(ctx context.Context, input model.SavePostInput) (*model.Save, error) {
	panic(fmt.Errorf("not implemented: SavePost - SavePost"))
}

// ProvidePost is the resolver for the ProvidePost field.
func (r *mutationResolver) ProvidePost(ctx context.Context, input model.ProvidePostInput) (*model.Post, error) {
	panic(fmt.Errorf("not implemented: ProvidePost - ProvidePost"))
}

// ProvideAllPosts is the resolver for the ProvideAllPosts field.
func (r *mutationResolver) ProvideAllPosts(ctx context.Context, input *model.ProvideAllPostsInput) ([]*model.Post, error) {
	panic(fmt.Errorf("not implemented: ProvideAllPosts - ProvideAllPosts"))
}

// SaveComment is the resolver for the SaveComment field.
func (r *mutationResolver) SaveComment(ctx context.Context, input *model.SaveCommentInput) (*model.Save, error) {
	panic(fmt.Errorf("not implemented: SaveComment - SaveComment"))
}

// SaveCommentToComment is the resolver for the SaveCommentToComment field.
func (r *mutationResolver) SaveCommentToComment(ctx context.Context, input *model.SaveCommentToCommentInput) (*model.Save, error) {
	panic(fmt.Errorf("not implemented: SaveCommentToComment - SaveCommentToComment"))
}

// ProvideComment is the resolver for the ProvideComment field.
func (r *mutationResolver) ProvideComment(ctx context.Context, input *model.ProvideCommentInput) ([]*model.Comment, error) {
	panic(fmt.Errorf("not implemented: ProvideComment - ProvideComment"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
